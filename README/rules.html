<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Readme</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/night.css" />
<script type="text/javascript" src="https://stackedit.io/libs/MathJax/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><h1 id="snet-fe-baseline-20">
<h1 id="regeln-f-r-snet_febaseline">Regeln für snet_feBaseline</h1>
<h2 id="ordnerstruktur">Ordnerstruktur</h2>
<ul>
<li><p><strong>css</strong></p>
<ul>
<li>main.css</li>
<li>start.css</li>
</ul>
</li>
<li><p><strong>scss</strong></p>
<ul>
<li><p><strong>_pages</strong></p>
<ul>
<li><p><strong>main.scss:</strong></p>
<pre><code>  @import &#39;../functions/all&#39;;
  @import &#39;../mixins/all&#39;;
  @import &#39;../framework/all&#39;;
  @import &#39;../modules/all&#39;;</code></pre>
</li>
<li><p><strong>start.scss:</strong></p>
<pre><code>  @import &#39;../content-start&#39;;</code></pre>
</li>
</ul>
</li>
<li><p><strong>_sections</strong> (enthält Extensions)</p>
</li>
<li><p><strong>_vendor</strong> (enthält z. B. JS-Schnipsel wie die Swipebox)</p>
</li>
<li><p><strong>framework</strong> (enthält Basisdateien)</p>
<ul>
<li><strong>_all.scss:</strong> importiert die nachfolgenden Dateien</li>
<li><strong>_base.scss:</strong> Styles für HTML-Elemente</li>
<li><strong>_layout.scss:</strong></li>
<li><strong>_normalize.scss:</strong> für gleiche Ausgangsbasis in versch. Browsern</li>
<li><strong>_variables.scss:</strong> für Projekt definierte Variablen (Farbwerte, Schriftarten + -Größen, Breitenangaben...)</li>
</ul>
</li>
<li><p><strong>functions</strong></p>
</li>
<li><p><strong>mixins</strong></p>
<ul>
<li><strong>_mq.scss:</strong> Mediaqueries</li>
<li><strong>_rem.scss</strong></li>
</ul>
</li>
<li><p><strong>modules</strong></p>
<ul>
<li><strong>_all.scss:</strong> importiert die nachfolgenden Dateien (außer die für die Startseite)</li>
<li><strong>_header.scss</strong></li>
<li><strong>_content.scss</strong></li>
<li><strong>_content-start.scss</strong></li>
<li><strong>_footer.scss</strong></li>
<li>etc.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="html-css-namensgebung">HTML / CSS Namensgebung</h2>
<ul>
<li>IDs nicht für Styling, nur für Javascript oder Anker benutzen</li>
<li>Klassennamen sinnvoll vergeben nach Inhalt, nicht nach Aussehen</li>
<li>CSS Selektoren nur auf Klassen beziehen, nicht auf Elementname, wenn möglich</li>
<li><p>Benennung nach BEM</p>
<ul>
<li><p>= block-element- -modifier</p>
<pre><code>  nav-list--level1</code></pre>
</li>
<li><p>Kleinschreibung, kein CamelCase!</p>
<pre><code>  .headerimage statt .headerImage</code></pre>
</li>
<li>Keine Bindestriche, außer für BEM-Syntax</li>
<li>Keine Unterstriche</li>
<li><p>Es kann Sub-Elemente von Elementen geben</p>
<pre><code>  .nav-list-item</code></pre>
</li>
<li><p>Es kann Sub-Modifier von Modifiern geben</p>
<pre><code>  .nav-list--level1--active</code></pre>
</li>
<li><p>Nur der Block bzw. das Eltern-Element enthält den Modifier, die darunterliegenden Elemente nicht</p>
<pre><code>  .nav-list--level2 &gt; .nav-list-item</code></pre>
</li>
<li>Ein Element muss im eindeutigen Kontext zum Block bzw. Eltern-Element stehen</li>
<li>Allgemeine globale Klassen sind gültig</li>
<li><p>Allgemeine Klassen, die sich innerhalb eines Blocks geringfügig anders verhalten, werden in Abhängigkeit vom Block gestyled, aber nicht als BEM-Klassen</p>
<pre><code>  .logo { }
  .header .logo { }</code></pre>
</li>
<li><p>Helferklassen zur Userinteraktion sind nicht nach BEM-Muster benannt</p>
<pre><code>  .active, .inactive</code></pre>
</li>
<li><p>Klassen, die nicht zur Gestaltung eines Elements, sondern ausschließlich zum Interagieren mit Javascript bestehen, sollten mit dem Präfix <code>js-</code> gekennzeichnet werden</p>
<pre><code>  div class=&quot;js-draggable&quot;, a class=&quot;js-togglecontent&quot;, ...</code></pre>
</li>
<li><p>zu testen: Jeder CSS-&quot;Befehl&quot; sollte aus nicht mehr als 3 einzelnen Selektoren bestehen (Pseudo-Klassen NICHT inbegriffen)</p>
<pre><code>  .nav--main .nav-list--level1 &gt; .nav-list-item</code></pre>
</li>
<li>Widerspricht nicht dem Einsatz von Bootstrap oder anderen Frameworks, diese sind wie bisher als globale Klassen ohne BEM zu benutzen, grundsätzlich sollten größere Externe Komponenten wie CSS-Frameworks, allerdings, sofern möglich, ebenfalls mit einem eindeutigen Präfix versehen werden, z.B. <code>tbs-Klassenname</code></li>
<li><p>Hilfsklassen (Wrapper- oder Container-Klassen) werden innerhalb der Block-Klasse als Element-Klasse &quot;blockname-frame&quot; aufgeführt, können aber in Unter-Element-Klassen aus semantischen Gründen aus dem BEM-String weggelassen werden</p>
<pre><code>  .content
      .content-frame --&gt; Hilfsklasse für Breitenangaben/Margins
          .content-main
          .content-additional</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="css-grid">CSS Grid</h2>
<p>Mit <a href="http://neat.bourbon.io/">Neat</a> wurde ein neues Grid-System eingeführt. Neat ist eine leichtgewichtige Sammlung an Mixins und Variablen für Sass und basiert auf <a href="http://bourbon.io/">Bourbon</a>, ebenfalls eine Mixin-Sammlung für Sass.</p>
<p>Die Installation der beiden Tools erfolgt automatisch mit dem Befehl <code>npm install</code> über das Node-Plugin <code>node-neat</code>, anschließend stehen die beiden Libraries ohne weiteres Zutun zur Verfügung.</p>
<p>Um das Grid-System zu nutzen, müssen die drei Sass-Variablen <code>$width-total</code>, <code>$width-margin</code> und <code>$width-column</code> in der Datei <code>framework/_variables.scss</code> mit konkreten Pixelwerten befüllt werden. In der Datei <code>framework/_grid.scss</code> lässt sich über die Variable <code>$grid-columns</code> die Anzahl der zu verwendenden Spalten festlegen. Anhand der vier oben genannten Variablen werden automatisch die nötigen prozentualen Werte für Spaltenbreite und -abstände berechnet.</p>
<p>Anschließend kann man den gewünschten HTML-Elementen über den Mixin Aufruf</p>
<pre><code>@include span-columns(SPALTENZAHL);</code></pre>
<p>eine Spaltigkeit zuweisen. Für das Definieren einer Spalte innerhalb einer Spalte in der richtigen Breite gibt es ebenfalls einen Aufruf:</p>
<pre><code>@include span-columns(KIND-SPALTENZAHL of ELTERN-SPALTENZAHL);</code></pre>
<p>Sowohl Bourbon als auch Neat besitzen natürlich eine Vielzahl weiterer Mixins und Funktionen, die ebenfalls benutzt werden können, hierfür lohnt sich ein Blick in die jeweiligen Dokumentationen (<a href="http://bourbon.io/docs/">Bourbon</a>, <a href="http://neat.bourbon.io/docs/">Neat</a>).</p>
<h2 id="css-minimierung">CSS-Minimierung</h2>
<p>Beim Ändern bzw. Speichern von scss-Dateien generiert grunt automatisch eine minimierte Version aller aus Sass generierten CSS Dateien. Diese werden im Ordner <code>Resources/Public/Styles/css/</code> abgelegt. Dieser Pfad wird auch für die TS-Konstante <code>$snet_tmpl_basic.cssRootPath</code> verwendet. Aus Performancegründen sollten im Produktiveinsatz grundsätzlich die minimierten Dateien zum Einsatz kommen.</p>
<p>Dank der Sourcemaps sind die minimierten Dateien trotzdem auch zum Debuggen und Testen geeignet (siehe unten).</p>
<h2 id="css-source-maps">CSS Source Maps</h2>
<p>Die aus den Sass-Dateien generierten CSS-Files werden im Ordner <code>Resources/Public/Styles/css/</code> abgelegt. Dank der CSS Source Maps kann man trotz Nutzung der generierten CSS-Dateien direkt im Browser prüfen, aus welcher Sass-Datei genau welche Styleregel stammt.</p>
<p>Diese Funktion kann in aktuellen Versionen der Browser <code>Chrome</code> und <code>Firefox</code> genutzt werden. Dazu muss man lediglich die Developer Tools (Taste <code>F12</code>) öffnen und in den Einstellungen die Source Maps aktivieren. Anschließend kann man über den Inspektor direkt die Herkunft der Styleregeln aus den Sass-Dateien einsehen.</p>
<h2 id="javascript-loading">Javascript-Loading</h2>
<p>Einführung von <code>headjs</code> als &quot;conditional resource loader&quot; zum besseren steuern, welches Skript wann in welcher Abhängigkeit geladen werden soll.</p>
<ul>
<li>Über TYPOSCRIPT werden nur noch <code>headjs</code> selbst und die Datei <code>scriptloader.js</code> geladen, die als Einstieg dienen.</li>
<li>In der <code>scriptloader.js</code> werden alle nötigen weiteren Skripte geladen und definiert.</li>
<li>Das &quot;herkömmliche Laden&quot; von CSS-Dateien und Skripten aus Extensions (z.B. Powermail) wird, sofern möglich, über TYPOSCRIPT vollständig deaktiviert, stattdessen werden die Skripte über die  <code>scriptloader.js</code> Datei eingebaut</li>
<li>Das Grundgerüst des neuen Workflows besteht aus 4 Skripten<ul>
<li><a href="http://headjs.com/">headjs</a> für asynchrones Laden von Ressourcen</li>
<li><a href="http://modernizr.com/">Modernizr</a> für Javascript-basierte Feature Detection</li>
<li><a href="http://jquery.com/">jQuery</a> für Element-Selektion und -Manipulation</li>
<li><a href="https://github.com/sparkbox/mediaCheck">MediaCheck</a> für Code-Ausführung beim Betreten und Verlassen von Responsive Breakpoints</li>
</ul>
</li>
<li>Diese vier Skripte stellen die Basis dar um sauber und strukturiert mit Javascript zu arbeiten, sollen aber im Produktiveinsatz nur dann auch geladen werden, wenn sie gebraucht werden</li>
<li>Einige Beispiele zum Einsatz und zur Syntax von <code>headjs</code> sind in der <code>scriptloader.js</code> vorhanden.</li>
<li>Tiefergreifende Erklärungen zu Syntax und Einsatzzwecken der jeweiligen Tools finden sich auf den jeweiligen Homepages</li>
</ul>

</div></body>
</html>